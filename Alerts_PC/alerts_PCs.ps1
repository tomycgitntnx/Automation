<#
.SYNOPSIS
    Gathers unresolved alerts from specific or all Nutanix Prism Central instances and generates an HTML report.

.DESCRIPTION
    This script connects to one or more Nutanix Prism Central (PC) instances to retrieve all unresolved alerts
    using the Nutanix v4 REST API.

    You can specify which PCs to target using the -PCAddress parameter. If no addresses are provided,
    the script defaults to reading all PCs from the 'clusters.txt' file.

    Features:
    - Target specific PCs via command-line parameter.
    - Enforces TLS 1.2 for secure API communication.
    - Securely stores and reuses credentials.
    - Handles API pagination to retrieve all alerts.
    - Filters alerts to show only those originating from Prism Element (PE) clusters.
    - Generates a timestamped HTML report with alerts organized by cluster.
    - Styles alerts by severity (Critical: Red, Warning: Yellow, Info: Blue).
    - Creates collapsible sections for each cluster and a summary index at the top.
    - Maintains a master 'index.html' file to link to all historical reports, organized by month.

.PARAMETER PCAddress
    An array of strings containing the IP addresses or FQDNs of the Prism Central instances to query.
    If not provided, the script will read addresses from the PCListFile.

.EXAMPLE
    # Run against specific PCs
    .\Get-NutanixUnresolvedAlerts.ps1 -PCAddress "pc1.mydomain.local", "192.168.10.100"

.EXAMPLE
    # Run against all PCs defined in clusters.txt
    .\Get-NutanixUnresolvedAlerts.ps1

.NOTES
    Author: Tomy Carrasco (Generated by GleanAI)
    Date: 2025-Nov-03 (Revised)
    PowerShell Version: 5.1+
#>
param (
    [string[]]$PCAddress
)

# --- Script Configuration ---
$Username = "admin"
$CredentialFile = "nutanix_cred.xml"
$PCListFile = "clusters.txt"
$ReportsFolder = "reports"
$MainIndexFile = "index.html"

# --- Force TLS 1.2 for all web requests ---
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12

# --- Main Script Body ---
Function Get-CredentialSecure {
    param (
        [string]$CredentialFile,
        [string]$Username
    )

    $keyPath = Join-Path $env:USERPROFILE "key.key"

    if (Test-Path $CredentialFile) {
        try {
            if (-not (Test-Path $keyPath)) {
                Write-Warning "Encryption key file not found at '$keyPath'. Password must be re-entered."
                throw "Key file missing."
            }
            $key = Get-Content -Path $keyPath
            $Password = Get-Content $CredentialFile | ConvertTo-SecureString -Key $key
            return New-Object System.Management.Automation.PSCredential($Username, $Password)
        }
        catch {
            Write-Warning "Could not decrypt the password file. Please re-enter the password."
        }
    }

    $Password = Read-Host "Enter the password for user '$Username'" -AsSecureString
    if ($Password.Length -eq 0) {
        Write-Error "Password cannot be empty." -ErrorAction Stop
    }

    # If the key doesn't exist, create it.
    if (-not (Test-Path $keyPath)) {
        # Using a fixed string to generate the key.
        $secureString = "your-secret-key-phrase-123456" | ConvertTo-SecureString -AsPlainText -Force
        $secureString | ConvertFrom-SecureString | Out-File -FilePath $keyPath
    }

    $key = Get-Content -Path $keyPath
    $Password | ConvertFrom-SecureString -Key $key | Set-Content $CredentialFile
    return New-Object System.Management.Automation.PSCredential($Username, $Password)
}

Function Get-NutanixUnresolvedAlerts {
    param (
        [string]$PC,
        [System.Management.Automation.PSCredential]$Credential
    )

    $allAlerts = @()
    $page = 0
    $pageSize = 500

    $baseUri = "https://$($PC):9440/api/monitoring/v4.0.a1/alerts?`$filter=isResolved eq false&`$expand=sourceEntity,affectedEntities&`$orderby=creationTime desc&`$limit=$($pageSize)"
    $currentUri = $baseUri

    Write-Host "Connecting to Prism Central: $PC"
    # Temporarily bypass certificate validation for lab environments.
    [System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true }

    do {
        $hasNextPage = $false
        Write-Host "  Fetching alerts (Page $($page + 1))..."
        try {
            $response = Invoke-RestMethod -Uri $currentUri -Method Get -Credential $Credential -ContentType "application/json" -ErrorAction Stop
            if ($null -ne $response.data) {
                $allAlerts += $response.data
            }
            $nextLink = $response.metadata.links | Where-Object { $_.rel -eq 'next' }
            if ($nextLink) {
                $currentUri = "https://$($PC):9440$($nextLink.href)"
                $hasNextPage = $true
                $page++
            }
        }
        catch {
            Write-Error "Failed to retrieve alerts from $PC. Error: $($_.Exception.Message)"
            return $null
        }
    } while ($hasNextPage)

    Write-Host "  Found $($allAlerts.Count) unresolved alerts on $PC."
    return $allAlerts
}

Function Get-HtmlStyle {
    return @"
<style>
    body { font-family: Calibri, sans-serif; font-size: 11pt; }
    h1 { font-size: 24px; color: #333; text-align: center; }
    h2 { font-size: 20px; color: #444; border-bottom: 2px solid #ccc; padding-bottom: 5px; margin-top: 30px; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; border: 1px solid #ddd; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; word-wrap: break-word; }
    th { background-color: #004071; color: white; }
    tr:nth-child(even) { background-color: #f2f2f2; }
    .collapsible { background-color: #004071; color: white; cursor: pointer; padding: 12px; width: 100%; border: none; text-align: left; outline: none; font-size: 16px; font-weight: bold; }
    .active, .collapsible:hover { background-color: #005a9e; }
    .content { padding: 0 18px; max-height: 0; overflow: hidden; transition: max-height 0.2s ease-out; background-color: #f9f9f9; }
    .open { max-height: none; }
    .severity-CRITICAL { color: red; font-weight: bold; }
    .severity-WARNING { color: #b78600; font-weight: bold; }
    .severity-INFO { color: blue; font-weight: bold; }
    .summary-table th, .summary-table td { width: 50%; }
    .summary-cell span { margin-right: 15px; }
    .back-to-top { float: right; font-size: 12px; margin-top: -25px; }
</style>
<script>
function toggleCollapse(button) {
    button.classList.toggle("active");
    var content = button.nextElementSibling;
    if (content.style.maxHeight && content.style.maxHeight !== "0px"){
        content.style.maxHeight = "0px";
    } else {
        content.style.maxHeight = content.scrollHeight + "px";
    }
}
document.addEventListener("DOMContentLoaded", function() {
    var coll = document.getElementsByClassName("collapsible");
    for (var i = 0; i < coll.length; i++) {
        var content = coll[i].nextElementSibling;
        content.style.maxHeight = content.scrollHeight + "px";
    }
});
</script>
"@
}

# --- Main Logic ---

# 1. Determine which PCs to process
$targetPCs = @()
if ($PSBoundParameters.ContainsKey('PCAddress')) {
    Write-Host "Targeting specific PCs provided via -PCAddress parameter."
    $targetPCs = $PCAddress
}
else {
    Write-Host "No specific PCs provided. Reading list from '$PCListFile'."
    if (-not (Test-Path $PCListFile)) {
        Write-Error "PC list file '$PCListFile' not found. Please create it or use the -PCAddress parameter." -ErrorAction Stop
    }
    $targetPCs = Get-Content $PCListFile | Where-Object { $_.Trim() -ne "" }
}

if ($targetPCs.Count -eq 0) {
    Write-Error "No Prism Central targets found. Halting script." -ErrorAction Stop
}
Write-Host "The following PCs will be queried: $($targetPCs -join ', ')"

# 2. Setup and Credential Handling
if (-not (Test-Path $ReportsFolder)) {
    New-Item -ItemType Directory -Path $ReportsFolder | Out-Null
}
$Credential = Get-CredentialSecure -CredentialFile $CredentialFile -Username $Username

# 3. Data Collection from all targeted PCs
$allClustersData = @{}
foreach ($pc in $targetPCs) {
    $alerts = Get-NutanixUnresolvedAlerts -PC $pc -Credential $Credential
    if ($null -eq $alerts) { continue }

    $alerts | Where-Object { $_.sourceEntity.type -eq 'nutanix_cluster' } | Group-Object { $_.sourceEntity.name } | ForEach-Object {
        $clusterName = $_.Name
        if (-not $allClustersData.ContainsKey($clusterName)) {
            $allClustersData[$clusterName] = @{ Alerts = @(); Summary = @{ CRITICAL = 0; WARNING = 0; INFO = 0 } }
        }
        $allClustersData[$clusterName].Alerts += $_.Group
    }
}

# 4. Process and Summarize Data
if ($allClustersData.Count -eq 0) {
    Write-Warning "No unresolved alerts found on any of the targeted Prism Element clusters."
} else {
    foreach ($clusterName in $allClustersData.Keys) {
        $clusterAlerts = $allClustersData[$clusterName].Alerts
        $allClustersData[$clusterName].Summary.CRITICAL = ($clusterAlerts | Where-Object { $_.severity -eq 'CRITICAL' }).Count
        $allClustersData[$clusterName].Summary.WARNING = ($clusterAlerts | Where-Object { $_.severity -eq 'WARNING' }).Count
        $allClustersData[$clusterName].Summary.INFO = ($clusterAlerts | Where-Object { $_.severity -eq 'INFO' }).Count
    }
}

# 5. Generate HTML Report
$reportTimestamp = Get-Date -Format "MM_dd_yyyy__HH_mm_ss"
$reportFileName = "Nutanix_Unresolved_Alerts_$($reportTimestamp).html"
$reportFilePath = Join-Path $ReportsFolder $reportFileName

$htmlFragments = @("<h1>Nutanix Unresolved Alerts Report</h1>", "<h2>Generated on: $(Get-Date)</h2>")

# Summary Index Table
$htmlFragments += "<a name='index'></a><h2>Alerts Summary</h2>"
if ($allClustersData.Count -gt 0) {
    $summaryTable = "<table class='summary-table'><tr><th>Cluster Name</th><th>Alerts</th></tr>"
    foreach ($clusterName in $allClustersData.Keys.GetEnumerator() | Sort-Object) {
        $summary = $allClustersData[$clusterName].Summary
        $summaryText = "<span class='severity-CRITICAL'>Critical: $($summary.CRITICAL)</span><span class='severity-WARNING'>Warning: $($summary.WARNING)</span><span class='severity-INFO'>Info: $($summary.INFO)</span>"
        $summaryTable += "<tr><td><a href='#$($clusterName)'>$clusterName</a></td><td class='summary-cell'>$summaryText</td></tr>"
    }
    $summaryTable += "</table>"
    $htmlFragments += $summaryTable

    # Detailed Alerts per Cluster
    foreach ($clusterName in $allClustersData.Keys.GetEnumerator() | Sort-Object) {
        $htmlFragments += "<a name='$($clusterName)'></a><button type='button' class='collapsible' onclick='toggleCollapse(this)'>Cluster: $clusterName</button>"
        $htmlFragments += "<div class='content open'><a href='#index' class='back-to-top'>Back to Index</a>"

        $table = $allClustersData[$clusterName].Alerts | ForEach-Object {
            $cause = if ($_.rootCauseAnalysis) { $_.rootCauseAnalysis.cause -join " " } else { "N/A" }
            $resolution = if ($_.rootCauseAnalysis) { $_.rootCauseAnalysis.resolution -join " " } else { "N/A" }
            [PSCustomObject]@{
                Severity         = "<span class='severity-$($_.severity)'>$($_.severity)</span>"
                Title            = $_.title
                Message          = $_.message
                Cause            = $cause
                Resolution       = $resolution
                SourceEntity     = $_.sourceEntity.name
                AffectedEntities = ($_.affectedEntities | ForEach-Object { $_.name }) -join ", "
                CreationTime     = $_.creationTime
                LastUpdatedTime  = $_.lastUpdatedTime
            }
        } | ConvertTo-Html -Fragment
        $htmlFragments += $table
        $htmlFragments += "</div>"
    }
} else {
    $htmlFragments += "<p>No unresolved alerts to display.</p>"
}

ConvertTo-Html -Head (Get-HtmlStyle) -Body ($htmlFragments -join "`r`n") | Out-File -FilePath $reportFilePath
Write-Host "HTML report generated at: $reportFilePath"

# 6. Update Main Index HTML File
$mainIndexFragments = @("<h1>Nutanix Alerts Report Index</h1>", "<h2>Generated on: $(Get-Date)</h2>")
$reports = Get-ChildItem -Path $ReportsFolder -Filter "*.html" | Sort-Object CreationTime -Descending
$groupedReports = $reports | Group-Object { $_.CreationTime.ToString("MMMM yyyy") }

foreach ($group in $groupedReports) {
    $mainIndexFragments += "<button type='button' class='collapsible' onclick='toggleCollapse(this)'>$($group.Name)</button><div class='content open'><ul>"
    foreach ($report in $group.Group) {
        $relativePath = Join-Path $ReportsFolder $report.Name
        $mainIndexFragments += "<li><a href='$($relativePath)'>$($report.Name)</a></li>"
    }
    $mainIndexFragments += "</ul></div>"
}

ConvertTo-Html -Head (Get-HtmlStyle) -Body ($mainIndexFragments -join "`r`n") | Out-File -FilePath $MainIndexFile
Write-Host "Main index file updated: $MainIndexFile"
