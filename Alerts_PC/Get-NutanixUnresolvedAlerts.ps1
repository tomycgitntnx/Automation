<#
.SYNOPSIS
    This script connects to one or more Nutanix Prism Central instances using the v4 REST API
    to collect all unresolved alerts and generate a color-coded HTML report.

.DESCRIPTION
    The script takes a list of Prism Central (PC) IPs or FQDNs as input. It securely prompts
    for credentials, then iterates through each PC to fetch unresolved alerts via the
    /api/monitoring/v4.0/serviceability/alerts endpoint.

    The output is a single HTML file saved to the user's desktop, with alerts grouped by
    cluster. Rows are color-coded based on severity:
    - CRITICAL: Red
    - WARNING: Yellow
    - INFO: Blue

.PARAMETER PcAddresses
    An array of strings containing the IP addresses or FQDNs of the Prism Central instances
    to query.

.EXAMPLE
    .\Get-NutanixUnresolvedAlerts.ps1 -PcAddresses "pc1.mydomain.com", "10.0.0.100"

.NOTES
    Author: Tomy Carrasco (Generated by Assistant)
    Date: 2025-Oct-20
    Version: 1.1
    - Compatible with PowerShell 5.1 and later.
    - Ensure network connectivity to the specified Prism Central instances on port 9440.
    
.How to Run the Script
 Replace the example IPs with your actual Prism Central IPs or FQDNs
 Example:   Get-NutanixUnresolvedAlerts -PcAddresses "192.168.1.10", "pc-secondary.corp.local"
#>

function Get-NutanixUnresolvedAlerts {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        [string[]]$PcAddresses
    )

    # --- Script Configuration ---
    $credential = Get-Credential -Message "Enter Nutanix Prism Central Credentials (e.g., admin)"
    $outputFile = "$([Environment]::GetFolderPath('Desktop'))\Nutanix_Unresolved_Alerts.html"
    $allAlerts = @()

    # --- PowerShell 5.1 Compatibility Section ---
    # In PowerShell 5.1, Invoke-RestMethod uses TLS 1.0 by default, which may be disabled on modern systems.
    # The line below forces the use of a more secure protocol like TLS 1.2 for the session.
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

    # Ignore SSL/TLS certificate errors for self-signed certificates.
    # This is common in lab or internal environments. For production, consider using trusted certificates.
    add-type @"
    using System.Net;
    using System.Security.Cryptography.X509Certificates;
    public class TrustAllCertsPolicy : ICertificatePolicy {
        public bool CheckValidationResult(ServicePoint srvPoint, X509Certificate certificate, WebRequest request, int certificateProblem) {
            return true;
        }
    }
"@
    [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy

    # --- Main Processing Loop ---
    foreach ($pc in $PcAddresses) {
        Write-Host "Connecting to Prism Central: $pc"
        $apiUrl = "https://{0}:9440/api/monitoring/v4.0/serviceability/alerts" -f $pc
        $authHeader = "Basic " + [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes(("{0}:{1}" -f $credential.UserName, $credential.GetNetworkCredential().Password)))

        $headers = @{
            "Authorization" = $authHeader
            "Content-Type"  = "application/json"
        }

        # The v4 API filter for unresolved alerts is `isResolved eq false`. We also expand the sourceEntity to get the cluster name.
        $filter = '?$filter=isResolved eq false&$expand=sourceEntity'
        $fullUrl = $apiUrl + $filter

        try {
            # In PS 5.1, Invoke-RestMethod automatically converts the JSON response to a PowerShell object.
            $response = Invoke-RestMethod -Uri $fullUrl -Method Get -Headers $headers -ErrorAction Stop

            if ($null -ne $response.data) {
                Write-Host "Successfully retrieved $($response.data.Count) unresolved alerts from $pc."
                # Add the PC address to each alert object for grouping later
                $response.data | ForEach-Object {
                    $_ | Add-Member -MemberType NoteProperty -Name "PrismCentral" -Value $pc
                    $allAlerts += $_
                }
            } else {
                Write-Host "No unresolved alerts found on $pc."
            }
        }
        catch {
            Write-Warning "Failed to retrieve alerts from $pc. Error: $($_.Exception.Message)"
        }
    }

    # --- HTML Report Generation ---
    if ($allAlerts.Count -gt 0) {
        Write-Host "Generating HTML report..."

        $head = @"
<style>
    body { font-family: 'Segoe UI', Arial, sans-serif; }
    h1, h2 { color: #003366; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
    th, td { border: 1px solid #dddddd; text-align: left; padding: 8px; }
    th { background-color: #f2f2f2; }
    .CRITICAL { background-color: #FFBABA; } /* Red */
    .WARNING { background-color: #FFF2BA; } /* Yellow */
    .INFO { background-color: #BAE1FF; } /* Blue */
</style>
"@

        $body = "<h1>Nutanix Unresolved Alerts Report</h1>"
        $body += "<p>Generated on: $(Get-Date)</p>"

        # Group alerts by the cluster they originated from
        $groupedAlerts = $allAlerts | Group-Object -Property { $_.sourceEntity.name }

        foreach ($group in $groupedAlerts) {
            $clusterName = if ($group.Name) { $group.Name } else { "Unknown Cluster" }
            $body += "<h2>Cluster: $clusterName</h2>"
            $body += "<table>"
            $body += "<tr><th>Severity</th><th>Message</th><th>Source Entity</th><th>Created Time</th><th>Prism Central</th></tr>"

            # Sort alerts within the group by severity (CRITICAL, WARNING, INFO)
            $sortedGroup = $group.Group | Sort-Object @{Expression={@('CRITICAL', 'WARNING', 'INFO').IndexOf($_.severity)}; Ascending=$true}

            foreach ($alert in $sortedGroup) {
                $severityClass = $alert.severity
                $body += "<tr class='$severityClass'>"
                $body += "<td>$($alert.severity)</td>"
                $body += "<td>$($alert.message)</td>"
                $body += "<td>$($alert.sourceEntity.name) ($($alert.sourceEntity.type))</td>"
                $body += "<td>$($alert.createdTimeStamp)</td>"
                $body += "<td>$($alert.PrismCentral)</td>"
                $body += "</tr>"
            }
            $body += "</table>"
        }

        # ConvertTo-Html is used here to create the final HTML structure before outputting to a file.
        ConvertTo-Html -Head $head -Body $body | Out-File -FilePath $outputFile
        Write-Host "Report successfully generated at: $outputFile"
    } else {
        Write-Host "No unresolved alerts found across all specified Prism Central instances. No report generated."
    }
}

